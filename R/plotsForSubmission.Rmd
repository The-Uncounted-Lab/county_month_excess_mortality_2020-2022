---
title: "Visualizations for journal submission"
author: "Joe A. Wasserman"
date: "`r format(Sys.time(), '%d %B %Y')`"
output: 
  html_document:
  toc: true
toc_float: true
always_allow_html: true
---
  
```{r setup, include=FALSE}
library(knitr)
library(ragg)
library(here)
library(extrafont)
library(colorspace)
library(tidyverse)
library(ggrepel)
library(ggh4x)
library(scales)
library(patchwork)
library(geofacet)
library(lubridate)

# prompt to register system fonts
# likely to take a long time, but only needs to be done once
# NOTE: requires a different version of Rttf2pt1 to work
# remotes::install_version("Rttf2pt1", version = "1.3.8")
if (is.null(extrafont::fonts())) extrafont::font_import()
loadfonts()
windowsFonts(Arial = windowsFont("Arial"))

# set default chunk options
knitr::opts_chunk$set(
  echo = FALSE,
  message = FALSE,
  warning = FALSE,
  include = FALSE,
  dev = "ragg_png"
)

# set global options
options(
  scipen = 999,
  verbose = FALSE
)

# set directories
here::i_am("R/plotsForSubmission.Rmd")

inDir <- here::here("data", "input")
outDir <- here::here("data", "output")
```

```{r ggplot globals}
# standard theme elements
theme_minimal2 <- theme_minimal() +
  theme(
    line = element_line(color = "grey40", linewidth = .2),
    text = element_text(
      family = "Arial",
      color = "grey10",
      size = 6
    ),
    rect = element_rect(color = "grey40", fill = "transparent", linewidth = .2)
  )

# color scales for corresponding number of bins
colorscaleGeyser21 <- colorspace::divergingx_hcl(21)

colorscaleRedYellow11 <- colorspace::sequential_hcl(
  palette = "Red-Yellow",
  n = 11L,
  rev = TRUE
)

colorscaleViridis11 <- colorspace::sequential_hcl(
  palette = "viridis",
  n = 11L
)

colorscaleVik10 <- colorspace::diverge_hcl(
  palette = "Vik",
  n = 10L
)

colorscaleHeatmap <- c("white", colorscaleRedYellow11[c(2, 4, 6, 8, 11)])

colorscaleCumulative <- c(colorscaleViridis11[c(3, 6, 9)], "black")

# line types
linetypeCumulative <- c("solid", "42", "12")

# grid of states for geofacet plot
us_state_grid_custom <- data.frame(
  row = c(1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 7, 6, 7),
  col = c(11, 10, 9, 8, 11, 10, 9, 8, 6, 5, 4, 3, 2, 1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 1, 2, 3, 4, 5, 6, 7, 8, 9, 8, 7, 6, 5, 4, 3, 11, 11, 7),
  code = c("ME", "MA", "NH", "VT", "RI", "CT", "NY", "PA", "MI", "MN", "SD", "ND", "MT", "WA", "OR", "ID", "WY", "NE", "IA", "WI", "IN", "WV", "NJ", "DE", "MD", "DC", "OH", "IL", "MO", "KS", "CO", "UT", "NV", "CA", "AZ", "NM", "OK", "AR", "KY", "TN", "NC", "VA", "SC", "GA", "AL", "MS", "LA", "TX", "HI", "AK", "FL"),
  name = c("Maine", "Massachusetts", "New Hampshire", "Vermont", "Rhode Island", "Connecticut", "New York", "Pennsylvania", "Michigan", "Minnesota", "South Dakota", "North Dakota", "Montana", "Washington", "Oregon", "Idaho", "Wyoming", "Nebraska", "Iowa", "Wisconsin", "Indiana", "West Virginia", "New Jersey", "Delaware", "Maryland", "District of Columbia", "Ohio", "Illinois", "Missouri", "Kansas", "Colorado", "Utah", "Nevada", "California", "Arizona", "New Mexico", "Oklahoma", "Arkansas", "Kentucky", "Tennessee", "North Carolina", "Virginia", "South Carolina", "Georgia", "Alabama", "Mississippi", "Louisiana", "Texas", "Hawaii", "Alaska", "Florida"),
  stringsAsFactors = FALSE
)
```


```{r import data}
# all-cause excess mortality estimates
try(monthlyEstimates <- read_csv(file.path(outDir, "estimates", "AC", "estimatesMonthlyFull.csv")) %>%
  mutate(monthYear = make_date(year = year, month = month)))

try(monthlyEstimatesState <- read_csv(file.path(outDir, "estimates", "AC", "estimatesStateMonths.csv")) %>%
  rename(monthYear = time))

# natural-cause excess mortality estimates
monthlyEstimatesNC <- read_csv(file.path(outDir, "estimates", "NC", "estimatesMonthly.csv")) %>%
  mutate(monthYear = make_date(year = year, month = month))

# load natural-cause, covid UCD posterior simulation draws
load(file.path(outDir, "modelsAndSimulations", "modelNC", "simulationsNCUCD.RData"))

# COVID deaths from WONDER
COVID_StateRaw <- data.table::fread(
        file.path(inDir, 'CDC', 'COVIDUCDData', 'stateMonth.txt'),
        na.strings = c("Missing", "Suppressed", "Not Applicable"),
        keepLeadingZeros = TRUE,
      )

COVID_MetroDivisionRaw <- data.table::fread(
        file.path(inDir, 'CDC', 'COVIDUCDData', 'metroDivisionMonth.txt'),
        na.strings = c("Missing", "Suppressed", "Not Applicable"),
        keepLeadingZeros = TRUE,
      )

COVID_MetroRegionRaw <- list.files(
      file.path(inDir, 'CDC', 'COVIDUCDData', 'regionMonth'),
      pattern = "*.txt",
      full.names = TRUE
    ) %>%
    map_dfr(
      ~ data.table::fread(
        .x,
        na.strings = c("Missing", "Suppressed", "Not Applicable"),
        keepLeadingZeros = TRUE,
      ) %>% 
        mutate(file = basename(.x))
    )

NC_MetroRegionRaw <- list.files(
      file.path(inDir, 'CDC', 'mortalityNCData', 'regionMonth'),
      pattern = "*.txt",
      full.names = TRUE
    ) %>%
    map_dfr(
      ~ data.table::fread(
        .x,
        na.strings = c("Missing", "Suppressed", "Not Applicable"),
        keepLeadingZeros = TRUE,
      ) %>% 
        mutate(file = basename(.x))
    )

# other datasets
# metroRaw <- read_csv(file.path(inDir, "utilities", "FIPSmetroregion4cat.csv"))
FIPSFixes <- read_csv(file.path(inDir, "FIPSHarmonization", "FIPSFixes.csv"))

popEst <- read_csv(file.path(inDir, "popData", "popEst20202021.csv")) %>%
  transmute(
    FIPSCode = paste0(STATE, COUNTY),
    pop = POPESTIMATE2020
  ) %>%
  left_join(FIPSFixes, by = "FIPSCode") %>%
  mutate(FIPSprovisional = coalesce(newFIPSCode, FIPSCode))
```
```{r deaths data prep}
# metro-region-month
## COVID
COVID_MetroRegion <- COVID_MetroRegionRaw %>% 
  mutate(
    metroCat3 = str_match(file, 'regionMonth([:alpha:]+)COVID')[,2],
    metroCat3 = case_when(
      metroCat3 == 'LargeMetro' ~ 'Large Metro',
      metroCat3 == 'MediumSmallMetro' ~ 'Medium or Small Metro',
      metroCat3 == 'NonMetro' ~ 'Non Metro'
    ),
    census_region = str_match(`Residence Census Region`,'Census Region \\d{1}: ([\\w\\s]+)')[,2]) %>%
  separate(`Month Code`, into=c('year', 'month'), sep='/', convert = T) %>%
  mutate(monthYear = make_date(year, month)) %>%
  select(census_region, metroCat3, monthYear, totalCOVIDDeaths = Deaths)

## NC
NC_MetroRegion <- NC_MetroRegionRaw %>% 
  mutate(
    metroCat3 = str_match(file, 'regionMonth([:alpha:]+)NaturalCause')[,2],
    metroCat3 = case_when(
      metroCat3 == 'LargeMetro' ~ 'Large Metro',
      metroCat3 == 'MediumSmallMetro' ~ 'Medium or Small Metro',
      metroCat3 == 'NonMetro' ~ 'Non Metro'
    ),
    census_region = str_match(`Residence Census Region`,'Census Region \\d{1}: ([\\w\\s]+)')[,2]) %>%
  separate(`Month Code`, into=c('year', 'month'), sep='/', convert = T) %>%
  mutate(monthYear = make_date(year, month)) %>%
  select(census_region, metroCat3, monthYear, totalDeaths = Deaths)

## combined
deaths_MetroRegion <- inner_join(COVID_MetroRegion, NC_MetroRegion) %>% 
  filter(monthYear >= make_date(2020, 3))

testthat::test_that(
  "no suppressed death values in region-metro-month WONDER extract", {
    testthat::expect_false(anyNA(deaths_MetroRegion))
  }
)

# metro-division-month
COVID_MetroDivision <- COVID_MetroDivisionRaw %>%
    separate(`Month Code`, into = c("year", "month"), sep = "/", convert = T) %>%
  mutate(
    monthYear = make_date(year, month),
    metroCat = `Residence 2013 Urbanization Code`,
    metroCat3 = case_when(
      metroCat %in% c(1, 2) ~ "Large Metro",
      metroCat %in% c(3, 4) ~ "Medium or Small Metro",
      metroCat %in% c(5, 6) ~ "Non Metro"
    ),
    census_division = str_match(
      `Residence Census Division`,
      "Division \\d{1}: ([\\w\\s]+)"
    )[, 2]
  ) %>%
  group_by(census_division, metroCat3, monthYear) %>% 
  summarize(
    totalCOVIDDeaths = sum(Deaths),
    .groups = "drop"
  )

# state-month
COVID_State <- COVID_StateRaw %>%
  separate(`Month Code`, into = c("year", "month"), sep = "/", convert = T) %>%
  mutate(monthYear = make_date(year, month)) %>%
  select(state = `Residence State`, stateFIPS = `Residence State Code`, monthYear, totalCOVIDDeaths = Deaths)
```

```{r simulation data prep division metro, cache=TRUE}
# note: V1:V1000 represent draws from the posterior of expected deaths of our model
simDF <- simulationsDF %>%
  mutate(
    monthYear = make_date(year = year, month = month),
    census_region = if_else(
      census_region == "North Central", "Midwest", census_region
    )
  ) %>%
  filter(monthYear >= make_date(2020, 3, 1))

# test that no simulation draws are NA
testthat::expect_false(simDF |> select(V1:V1000) |> anyNA())

# cumulative summation function that can handle NA values by replacing them with 0
cumsum_na <- function(x, na.rm = TRUE) {
  if( na.rm ) {
    x <- tidyr::replace_na(x, 0)
  }
  
  cumsum(x)
}

# cumulative difference function
cum_diff <- function(x, y, na.rm = TRUE) {
  cumsum_na(x, na.rm = na.rm) - cumsum_na(y, na.rm = na.rm)
}

# produce 3 columns of quantiles for prediction intervals
quantile_interval <- function(.x,
                              .vars,
                              .newVarName,
                              low = .05,
                              med = .5,
                              up = .95,
                              na.rm = TRUE) {

  .x |>
    dplyr::mutate(
      quantileTempLst = list(
        quantile(
          {{ .vars }}, probs = c(low, med, up), na.rm = na.rm
          )
        )
    ) |>
    tidyr::hoist(
      .col = "quantileTempLst",
      quantileTempLow = 1L,
      quantileTempMed = 2L,
      quantileTempUp = 3L
    ) |>
    dplyr::rename(
      "{{ .newVarName }}Low" := quantileTempLow,
      "{{ .newVarName }}Med" := quantileTempMed,
      "{{ .newVarName }}Up" := quantileTempUp
    )
}

# Eugenio's original code to summarize county-month to division-metro-month
metroDivisionMonthEugenioVersion <- simDF %>%
  group_by(census_division, metroCat3, monthYear) %>%
  summarise(
    across(V1:V1000, ~ (sum(imputedDeaths) - sum(.x))),
    COVIDDeaths = sum(imputedCOVIDDeaths),
    pop = sum(pop),
    .groups = "drop"
  ) %>%
  rowwise() %>%
  mutate(
    excLow = quantile(c_across(V1:V1000), 0.05),
    excMed = quantile(c_across(V1:V1000), 0.5),
    excUp = quantile(c_across(V1:V1000), 0.95)
  ) %>%
  quantile_interval(c_across(V1:V1000), testExc) %>%
  ungroup() %>%
  select(-c(V1:V1000))

testthat::test_that(
  "ensure quantile_interval function returns the same values",
  {
    testthat::expect_equivalent(
      select(metroDivisionMonthEugenioVersion, excLow:excUp),
      select(metroDivisionMonthEugenioVersion, testExcLow:testExcUp)
    )
  }
)

# summarize county-month to division-metro-month and cumulative to date
metroDivisionMonth <- simDF %>%
  # sum to division-metro-month
  group_by(census_division, metroCat3, monthYear) %>%
  summarise(
    across(
      V1:V1000,
      .fns = c(
        Sum = ~ sum(.x),
        Exc = ~ sum(imputedDeaths) - sum(.x)
      ),
      .names = "{.col}{.fn}"
    ),
    deaths = sum(imputedDeaths),
    pop = sum(pop),
    .groups = "drop"
  ) %>%
  # add COVID deaths already aggregated from WONDER extract
  left_join(
    COVID_MetroDivision,
    by = c("census_division", "metroCat3", "monthYear")
  ) %>%
  mutate(
    across(
      c(starts_with("V") & ends_with("Exc")),
      .fns = c(NC = ~ .x - totalCOVIDDeaths),
      .names = "{.col}{.fn}"
  )
  ) %>% 
  group_by(census_division, metroCat3) %>%
  mutate(
    # cumulative-to-month summations
    # entire period totals
    across(
      c(
        starts_with("V") & ends_with("Sum"), 
        starts_with("V") & ends_with("Exc"),
        starts_with("V") & ends_with("ExcNC"),
        deaths, 
        totalCOVIDDeaths
      ),
      .fns = c(
        Cumulative = ~ with_order(monthYear, cumsum_na, .x, na.rm = TRUE),
        Total = ~ sum(.x)
      ),
      .names = "{.col}{.fn}"
    )
  ) %>% 
  ungroup() %>% 
  mutate(
    # running relative COVID using period total expected as static denominator
    across(
      c(starts_with("V") & ends_with("SumTotal")),
      .fns = c(COVIDCumulativeRel = ~ 100 * totalCOVIDDeathsCumulative / .x),
      .names = "{.col}{.fn}"
    )
  ) %>% 
  rowwise() %>%
  mutate(
    # running cumulative relative excess using period total expected as static denominator
    excCumulativeRelLst = list(purrr::map2_dbl(
      .x = c_across(starts_with("V") & ends_with("ExcCumulative")),
      .y = c_across(starts_with("V") & ends_with("SumTotal")),
      ~ 100 * .x / .y
    ))
  ) %>%
  quantile_interval(unlist(excCumulativeRelLst), excCumulativeRel) %>%
  quantile_interval(
    c_across(starts_with("V") & ends_with("SumTotalCOVIDCumulativeRel")),
    COVIDCumulativeRel
  ) %>%
  quantile_interval(
    c_across(starts_with("V") & ends_with("SumTotal")), expTotal
  ) %>%
  quantile_interval(
    c_across(starts_with("V") & ends_with("Exc")), exc
  ) %>%
  quantile_interval(
    c_across(starts_with("V") & ends_with("ExcNC")), excNC
  ) %>%
  quantile_interval(
    c_across(starts_with("V") & ends_with("SumCumulative")), expCumulative
  ) %>%
  quantile_interval(
    c_across(starts_with("V") & ends_with("ExcCumulative")), excCumulative
  ) %>%
  quantile_interval(
    c_across(starts_with("V") & ends_with("ExcNCCumulative")), excNCCumulative
  ) %>%
  ungroup() %>%
  select(-c(starts_with("V"), excCumulativeRelLst))

testthat::test_that(
  "quantiles of excess deaths are identical between Eugenio's original code and this version",
  {
    testthat::expect_equivalent(
      metroDivisionMonthEugenioVersion |> arrange(census_division, metroCat3, monthYear) |> select(c(excLow:excUp)),
      metroDivisionMonth |> arrange(census_division, metroCat3, monthYear) |> select(c(excLow:excUp))
    )
  }
)
```
```{r sim data prep region metro, cache=TRUE}
# summarize county-month to region-metro-month and cumulative to date
metroRegionMonth <- simDF %>%
  # sum to region-metro-month
  group_by(census_region, metroCat3, monthYear) %>%
  summarise(
    across(
      V1:V1000,
      .fns = c(
        Sum = ~ sum(.x)
      ),
      .names = "{.col}{.fn}"
    ),
    pop = sum(pop),
    .groups = "drop"
  ) %>%
  # add COVID and NC deaths already aggregated from WONDER extract, which have no suppression
  left_join(
    deaths_MetroRegion, by = c("census_region", "metroCat3", "monthYear")
  ) %>%
  mutate(
    # excess and non-covid excess deaths, monthly
    across(
      c(starts_with("V") & ends_with("Sum")),
      .fns = c(
        Exc = ~ totalDeaths - .x,
        ExcNC = ~ totalDeaths - .x - totalCOVIDDeaths
        ),
      .names = "{.col}{.fn}"
  )
  ) %>% 
  group_by(census_region, metroCat3) %>%
  mutate(
    # entire period totals
    # cumulative-to-month summations
    across(
      c(
        starts_with("V"), # Sum [expected], SumExc, SumExcNC
        totalDeaths, 
        totalCOVIDDeaths
      ),
      .fns = c(
        Total = ~ sum(.x),
        Cumulative = ~ with_order(monthYear, cumsum_na, .x, na.rm = TRUE)
      ),
      .names = "{.col}{.fn}"
    )
  ) %>% 
  ungroup() %>% 
  mutate(
    # ratio of cumulative excess to cumulative covid
    across(
      c(starts_with("V") & ends_with("SumExcCumulative")),
      .fns = c(COVIDRatio = ~ .x / totalCOVIDDeathsCumulative),
      .names = "{.col}{.fn}"
    )
  ) %>%
  rowwise() %>%
  quantile_interval(
    c_across(starts_with("V") & ends_with("SumTotal")), expTotal
  ) %>%
  quantile_interval(
    c_across(starts_with("V") & ends_with("SumExc")), exc
  ) %>%
  quantile_interval(
    c_across(starts_with("V") & ends_with("SumExcNC")), excNC
  ) %>%
  quantile_interval(
    c_across(starts_with("V") & ends_with("SumExcCumulativeCOVIDRatio")), excessCOVIDRatioCumulative
  ) %>% 
  quantile_interval(
    c_across(starts_with("V") & ends_with("SumCumulative")), expCumulative
  ) %>%
  quantile_interval(
    c_across(starts_with("V") & ends_with("SumExcCumulative")), excCumulative
  ) %>%
  ungroup() %>%
  select(-c(starts_with("V")))
```

```{r simulation data prep state, cache=TRUE}
# summarize county-month to state-month and cumulative to date
stateMonthCumulative <- simDF %>%
  # sum to state-month
  group_by(state, monthYear) %>%
    summarise(
    across(
      V1:V1000,
      .fns = c(
        Sum = ~ sum(.x),
        Exc = ~ sum(imputedDeaths) - sum(.x)
      ),
      .names = "{.col}{.fn}"
    ),
    deaths = sum(imputedDeaths),
    pop = sum(pop),
    .groups = "drop"
  ) %>%
  # add COVID deaths already aggregated from WONDER extract
  left_join(
    COVID_State,
    by = c("state", "monthYear")
  ) %>%
  mutate(
    across(
      c(starts_with("V") & ends_with("Exc")),
      .fns = c(NC = ~ .x - totalCOVIDDeaths),
      .names = "{.col}{.fn}"
  )
  ) %>% 
  group_by(state, stateFIPS) %>%
  mutate(
    # cumulative-to-month summations
    across(
      c(starts_with("V") & ends_with("Sum"), deaths, totalCOVIDDeaths),
      .fns = c(Cumulative = ~ with_order(monthYear, cumsum_na, .x, na.rm = TRUE)),
      .names = "{.col}{.fn}"
    ),
    # cumulative-to-month excess mortality
    across(
      c(starts_with("V") & ends_with("Sum")),
      .fns = c(ExcCumulative = ~ with_order(monthYear, cum_diff, deaths, .x)),
      .names = "{.col}{.fn}"
    ),
    # entire period totals
    across(
      c(starts_with("V") & ends_with("Sum"), deaths, totalCOVIDDeaths),
      .fns = c(Total = ~ sum(.x)),
      .names = "{.col}{.fn}"
    ),
    # running relative COVID using period total expected as static denominator
    across(
      c(starts_with("V") & ends_with("SumTotal")),
      .fns = c(COVIDCumulativeRel = ~ 100 * totalCOVIDDeathsCumulative / .x),
      .names = "{.col}{.fn}"
    )
  ) %>%
  ungroup() %>%
  rowwise() %>%
  mutate(
    # running cumulative relative excess using period total expected as static denominator
    excCumulativeRelLst = list(purrr::map2_dbl(
      .x = c_across(starts_with("V") & ends_with("SumExcCumulative")),
      .y = c_across(starts_with("V") & ends_with("SumTotal")),
      ~ 100 * .x / .y
    ))
  ) %>%
  quantile_interval(unlist(excCumulativeRelLst), excCumulativeRel) %>%
  quantile_interval(
    c_across(starts_with("V") & ends_with("SumTotalCOVIDCumulativeRel")),
    COVIDCumulativeRel
  ) %>%
  quantile_interval(
    c_across(starts_with("V") & ends_with("SumTotal")), expTotal
  ) %>%
  quantile_interval(
    c_across(starts_with("V") & ends_with("Exc")), exc
  ) %>%
  quantile_interval(
    c_across(starts_with("V") & ends_with("ExcNC")), excNC
  ) %>%
  quantile_interval(
    c_across(starts_with("V") & ends_with("SumCumulative")), expCumulative
  ) %>%
  ungroup() %>%
  select(-c(starts_with("V"), excCumulativeRelLst))
```

```{r plot data prep}
## create de-duplicated version of population estimates w FIPS harmonized to our data ##
# identify changed FIPS that already exist with new value in pop estimates
popEstExistingNew <- popEst %>%
  filter(FIPSCode == newFIPSCode)

popEstDedup <- popEst %>%
  # remove all FIPS duplicated because new value already exists
  # add non-duplicate, final pop ests for those counties
  anti_join(popEstExistingNew, by = c("FIPSprovisional")) %>%
  bind_rows(popEstExistingNew) %>%
  transmute(
    FIPSCode = FIPSprovisional,
    pop
  ) %>%
  # sum population counts for remaining counties, which are duplicate because their areal units need combining
  group_by(FIPSCode) %>%
  summarise(pop = sum(pop), .groups = "drop")

## AC
# filter to first 24 pandemic months
# add "sig" flag, pop, and metro categories
plotData <- monthlyEstimates %>%
  filter(monthYear >= date("2020-03-01"), monthYear <= date("2022-02-01")) %>%
  arrange(FIPSCode, monthYear) %>%
  mutate(
    significant = coalesce(excDeathsLow > 0, FALSE),
    metroCat2 = case_when(
      metroCat %in% c("Large Fringe Metro", "Large Central Metro") ~ "Large metro",
      metroCat %in% c("Medium or Small Metro") ~ "Medium or small metro",
      TRUE ~ "Nonmetro"
    ),
    census_region = if_else(
      census_region == "North Central",
      "Midwest",
      census_region
    )
  ) %>%
  left_join(popEstDedup, by = "FIPSCode")

## NC
# filter to pandemic months
# add "sig" flag, pop, and metro categories
plotDataNC <- monthlyEstimatesNC %>%
  filter(monthYear >= date("2020-03-01")) %>%
  arrange(FIPSCode, monthYear) %>%
  mutate(
    significant = coalesce(excDeathsLow > 0, FALSE),
    metroCat2 = case_when(
      metroCat %in% c("Large Fringe Metro", "Large Central Metro") ~ "Large metro",
      metroCat %in% c("Medium or Small Metro") ~ "Medium or small metro",
      TRUE ~ "Nonmetro"
    ),
    census_region = if_else(
      census_region == "North Central",
      "Midwest",
      census_region
    )
  ) %>%
  left_join(popEstDedup, by = "FIPSCode")
```

```{r heatmap data prep}
# identify deciles to guide setting cut-points for bins for heatmaps
# plotDataHeatmap %>% filter(relExcDeathsMed > 0) %>% pull(relExcDeathsMed) %>% quantile(probs = seq(0, 1, .05), type = 8, digits = 4)
# .3, .6, .8, .95
breaksHeatmap <- c(-Inf, 0, .15, .30, .5, 1, Inf)

plotDataHeatmap <- plotData %>%
  group_by(FIPSCode) %>%
  mutate(
    excDeathsRelativeNoInf = na_if(relExcDeathsMed, Inf),
    excDeathsRelativeNoInf = na_if(excDeathsRelativeNoInf, -Inf),
    monthRank = rank(-excDeathsRelativeNoInf, ties.method = "first", na.last = "keep"),
    monthMax1 = if_else(monthRank == 1L, monthYear, NA_Date_),
    monthMax2 = if_else(monthRank == 2L, monthYear, NA_Date_),
    monthMax3 = if_else(monthRank == 3L, monthYear, NA_Date_)
  ) %>%
  fill(
    monthMax1,
    monthMax2,
    monthMax3,
    .direction = "updown"
  ) %>%
  ungroup() %>%
  arrange(
    # maxMonth
    monthMax1,
    monthMax2,
    monthMax3
  ) %>%
  mutate(
    excDeathsRelativeBinned = cut(
      relExcDeathsMed,
      breaks = breaksHeatmap,
      ordered_result = TRUE,
      right = FALSE
    ),
    FIPSPlotOrder = forcats::as_factor(FIPSCode),
    # create 12 evenly-spaced datetimes for nicer plotting
    monthNum = month(monthYear),
    yearStart = floor_date(monthYear, unit = "years"),
    yearEnd = ceiling_date(monthYear, unit = "years"),
    intervalSeconds = int_length(interval(yearStart, yearEnd)) / 12,
    monthYearPlot = yearStart + hours(14) + seconds((monthNum - 1) * intervalSeconds),
    monthTest = monthNum == month(monthYearPlot),
    stateAbbr = usdata::state2abbr(state),
    FIPSlabel = as.character(glue::glue("{countyName}, {stateAbbr}"))
  ) %>%
  arrange(metroCat2, FIPSPlotOrder) %>%
  mutate(
    FIPSPlotOrder = as_factor(FIPSlabel)
  )

# test that dates modified for plotting still fall within same month as in the original data
testthat::expect_true(all(plotDataHeatmap[["monthTest"]]))

FIPSTop50 <- plotDataHeatmap %>%
  distinct(FIPSCode, pop, metroCat2) %>%
  group_by(metroCat2) %>%
  arrange(desc(pop), .by_group = TRUE) %>%
  slice(1:50) %>%
  ungroup()

plotDataHeatmapSubset <- plotDataHeatmap %>%
  semi_join(FIPSTop50, by = "FIPSCode") %>%
  filter(metroCat2 %in% c("Large metro", "Nonmetro"))
```

# Extreme Excess

```{r extreme excess, include = TRUE, output='asis'}
excessSummary <- plotDataHeatmap %>%
  group_by(
    state,
    county = countyName,
    FIPSCode,
    censusDivision,
    metroGroup = metroStatus2,
    pop = popMax,
    peakMonth = monthMax1
  ) %>%
  summarize(
    maxExcess = max(excDeathsRelative),
    monthsOver100Pct = sum(excDeathsRelative > 1),
    cumulativeExcess =
      sum(excDeathsMed, na.rm = TRUE) /
        sum(expDeathsMed, na.rm = TRUE),
    .groups = "drop"
  )

excessExtreme <- excessSummary %>%
  filter(
    monthsOver100Pct > 2 |
      is.na(monthsOver100Pct) |
      is.na(peakMonth) |
      maxExcess > 2 |
      cumulativeExcess > 1
  )

plotExcessExtreme <- plotDataHeatmap %>%
  semi_join(excessExtreme, by = "FIPSCode")

readr::write_csv(
  excessExtreme,
  here::here(outDir, "countiesWithExcessiveExcess.csv")
)

excessExtreme %>%
  knitr::kable(digits = 2) %>%
  kableExtra::kable_styling(
    bootstrap_options = "condensed"
  ) %>%
  print()
```
```{r extreme excess descriptive plots}
gExcessExtreme <- ggplot(
  plotExcessExtreme,
  aes(x = monthYear)
)

excessExtremeOut <- gExcessExtreme +
  geom_hline(
    yintercept = 0,
    color = "grey40",
    linewidth = .2
  ) +
  ggh4x::stat_difference(
    aes(
      ymin = excDeathsMed,
      ymax = imputedCOVIDDeaths
    ),
    levels = c("Covid-19 Deaths", "Excess Deaths", NA),
    alpha = .75
  ) +
  geom_line(
    aes(
      y = excDeathsMed,
      color = "Excess Deaths"
    )
  ) +
  geom_line(
    aes(
      y = imputedCOVIDDeaths,
      color = "Covid-19 Deaths"
    )
  ) +
  geom_line(
    aes(
      y = expDeathsMed
    ),
    color = "red",
    linewidth = .3,
    linetype = "dotted"
  ) +
  scale_color_discrete_diverging(
    palette = "Vik",
    rev = TRUE,
    nmax = 10,
    order = c(2, 9)
  ) +
  scale_fill_discrete_diverging(
    palette = "Vik",
    rev = TRUE,
    nmax = 10,
    order = c(4, 7)
  ) +
  scale_x_date(
    breaks = scales::breaks_width(width = "6 months"),
    minor_breaks = scales::breaks_width(width = "3 months"),
    labels = scales::label_date_short(),
    guide = "axis_minor",
    expand = c(0, 0)
  ) +
  scale_y_continuous(
    breaks = scales::breaks_extended(n = 3),
    labels = scales::label_comma()
  ) +
  ggh4x::facet_nested_wrap(
    facets = vars(state, metroStatus2, countyName),
    ncol = 11,
    scales = "free_y",
    nest_line = element_line(),
    strip = strip_nested(
      clip = "off",
      by_layer_x = TRUE
    ),
    axes = "all",
    remove_labels = "x"
  ) +
  labs(
    y = "Deaths",
    x = NULL,
    color = NULL,
    fill = NULL
  ) +
  theme_minimal2 +
  theme(
    panel.grid.minor = element_blank(),
    axis.ticks.x = element_line(),
    axis.ticks.length.x = unit(2, "points"),
    ggh4x.axis.ticks.length.minor = rel(.6),
    axis.text.x = element_blank(),
    legend.position = "bottom",
    legend.justification = "center",
    legend.title.align = .5
  )
```
```{r export extreme excess}
ragg::agg_png(
  filename = here::here("figures", "excessExtreme.png"),
  width = 4000,
  height = 14400,
  res = 300
)
excessExtremeOut
dev.off()
```

# Heatmaps of relative county-month excess mortality as a % (excess / expected)

* Large metro = NCHS categories 1 + 2

* Small/Medium Metro = NCHS category 3

* All Metro = NCH categories 1, 2, + 3

* Non-metro = 4



Largest 50 counties per metro category

Rows (counties) ordered by peak month + second-highest month

```{r heatmap plot, include=TRUE}
# plot waves as line segment annotations
# waveRangePlot <- ggplot(waveRanges) +
#   geom_segment(
#     aes(
#       x = startWave_plot,
#       xend = endWave_plot
#     ),
#     y = 0,
#     yend = 0,
#     color = "grey70"
#   ) +
#   geom_text(
#     aes(
#       x = midWave_plot,
#       y = -.5 - (yjust * 1),
#       label = wave
#     ),
#     vjust = 1.5,
#     color = "grey10",
#     size = 2.5
#   ) +
#   coord_fixed(2628000 * .8, clip = "off") +
#   theme_void()

# function to plot heatmap and "significance" side by side
plot_heatmap <- function(.x,
                         plot_title = NULL) {
  gHeatmap <- ggplot(
    .x,
    aes(
      y = FIPSPlotOrder,
      x = monthYearPlot,
      fill = excDeathsRelativeBinned,
      width = intervalSeconds
    )
  )

  heatmapUnfaceted <- gHeatmap +
    geom_tile(
      color = "transparent"
    ) +
    scale_fill_manual(
      values = colorscaleHeatmap,
      labels = c(
        "\u22640%",
        "0-15%",
        "15-30%",
        "30-55%",
        "55-100%",
        ">100%"
      )
    ) +
    scale_x_datetime(
      breaks = scales::breaks_width(width = "6 months", offset = "1 month"),
      minor_breaks = scales::breaks_width(width = "3 months", offset = "1 month"),
      labels = scales::label_date_short(),
      guide = "axis_minor",
      expand = c(0, 0)
    ) +
    scale_y_discrete(
      # labels = NULL,
      limits = rev,
      expand = c(0, 0)
    ) +
    labs(
      title = plot_title,
      subtitle = "Relative excess mortality",
      x = NULL,
      y = NULL,
      fill = "Relative excess mortality (%)"
    ) +
    coord_fixed(2628000 * 1.3, expand = FALSE) +
    guides(
      fill = guide_legend(
        reverse = FALSE,
        nrow = 1,
        title.position = "top",
        override.aes = list(
          color = "grey40",
          size = .2
        )
      )
    ) +
    theme_minimal2 +
    theme(
      panel.border = element_rect(fill = "transparent"),
      panel.grid = element_blank(),
      axis.ticks.x = element_line(),
      axis.ticks.length.x = unit(3, "points"),
      ggh4x.axis.ticks.length.minor = rel(.6),
      legend.position = "bottom",
      legend.justification = "center",
      legend.title.align = .5,
      legend.key.size = unit(0.5, "cm")
    )

  significantTileUnfaceted <- gHeatmap +
    geom_tile(
      aes(
        fill = significant
      ),
      color = "transparent"
    ) +
    scale_fill_manual(
      values = c("white", "grey70"),
      labels = c(
        "\u226495%",
        ">95%"
      )
    ) +
    scale_x_datetime(
      breaks = scales::breaks_width(width = "6 months", offset = "1 month"),
      minor_breaks = scales::breaks_width(width = "3 months", offset = "1 month"),
      labels = scales::label_date_short(),
      guide = "axis_minor",
      expand = c(0, 0)
    ) +
    scale_y_discrete(
      labels = NULL,
      limits = rev,
      expand = c(0, 0)
    ) +
    labs(
      title = NULL,
      subtitle = "Probability of excess mortality > 0",
      x = NULL,
      y = NULL,
      fill = "Probability of excess mortality > 0"
    ) +
    coord_fixed(2628000 * 1.3, expand = FALSE) +
    guides(
      fill = guide_legend(
        reverse = FALSE,
        nrow = 1,
        title.position = "top",
        override.aes = list(
          color = "grey40",
          size = .2
        )
      )
    ) +
    theme_minimal2 +
    theme(
      panel.border = element_rect(fill = "transparent"),
      panel.grid = element_blank(),
      axis.ticks.x = element_line(),
      axis.ticks.length.x = unit(3, "points"),
      ggh4x.axis.ticks.length.minor = rel(.6),
      legend.position = "bottom",
      legend.justification = "center",
      legend.title.align = .5,
      legend.key.size = unit(0.5, "cm")
    )

  heatmapOutList <- list(heatmapUnfaceted, significantTileUnfaceted)
}

(heatmapOut <- plotDataHeatmapSubset %>%
  mutate(
    metroCat2 = case_when(
      metroCat2 == "Large metro" ~ "A. Large metro",
      metroCat2 == "Nonmetro" ~ "B. Nonmetro",
      TRUE ~ metroCat2
    )
  ) %>%
  group_by(metroCat2) %>%
  group_map(plot_heatmap) %>%
  map(wrap_plots) %>%
  map(~ .x[[1]] + .x[[2]]) %>%
  wrap_plots(
    nrow = 1,
    guides = "collect"
  ) &
  theme(
    legend.position = "bottom",
    legend.justification = "center",
    legend.title.align = .5
  )
)
```
```{r export heatmap}
# ragg::agg_png(
#   filename = here::here("figures", "heatmap.png"),
cairo_pdf(
  filename = here::here("figures", "figure6_heatmap.pdf"),
  width = 7.8,
  height = 4.55
)
heatmapOut
dev.off()
```
```{r appendix heatmaps, eval=FALSE}
# heatmapAppendixList <- plotDataHeatmap %>%
#   group_by(metroStatus2) %>%
#   group_map(plot_heatmap) %>%
#    map(wrap_plots)

gHeatmapAppendix <- ggplot(
  plotDataHeatmap,
  aes(
    y = FIPSPlotOrder,
    x = monthYearPlot,
    fill = excDeathsRelativeBinned,
    width = intervalSeconds
  )
)

heatmapAllCounty <- gHeatmapAppendix +
  geom_tile(
    color = "transparent"
  ) +
  scale_fill_manual(
    values = colorscaleHeatmap,
    labels = c(
      "=0%",
      "0-15%",
      "15-30%",
      "30-55%",
      "55-100%",
      ">100%"
    )
  ) +
  # ggh4x::facet_nested_wrap(
  #   facets = vars(census_division, metroStatus2),
  #   ncol = 3,
  #   scales = "free_y",
  #   nest_line = element_line(),
  #   # resect = unit(4, "points"),
  #   strip = strip_nested(
  #     clip = "off",
  #     text_x = list(
  #       element_text(size = 9),
  #       element_text()
  #     ),
  #     by_layer_x = TRUE
  #   ),
  #   axes = "all",
  #   remove_labels = "x"
  # ) +
  ggh4x::facet_grid2(
    cols = vars(metroStatus2),
    rows = vars(census_division),
    scales = "free_y",
    independent = "y",
    axes = "all",
    remove_labels = "x"
  ) +
  scale_x_datetime(
    breaks = scales::breaks_width(width = "6 months", offset = "1 month"),
    minor_breaks = scales::breaks_width(width = "3 months", offset = "1 month"),
    labels = scales::label_date_short(),
    guide = "axis_minor",
    expand = c(0, 0)
  ) +
  scale_y_discrete(
    # labels = NULL,
    limits = rev,
    expand = c(0, 0)
  ) +
  labs(
    title = NULL,
    subtitle = "Relative Excess Mortality",
    x = NULL,
    y = NULL,
    fill = "Relative Excess Mortality (%)"
  ) +
  # coord_fixed(2628000 * 1.3, expand = FALSE) +
  guides(
    fill = guide_legend(
      reverse = FALSE,
      nrow = 1,
      title.position = "top",
      override.aes = list(
        color = "grey40",
        size = .2
      )
    )
  ) +
  theme_minimal2 +
  theme(
    panel.border = element_rect(fill = "transparent"),
    panel.grid = element_blank(),
    axis.ticks.x = element_line(),
    axis.ticks.length.x = unit(3, "points"),
    ggh4x.axis.ticks.length.minor = rel(.6),
    legend.position = "bottom",
    legend.justification = "center",
    legend.title.align = .5,
    legend.key.size = unit(0.5, "cm")
  )

heatmapAllCounty
```
```{r export appendix heatmaps, eval=FALSE}
# saveHeatmap <- function(plot,
#                         plot_name = "",
#                         nrows = 50) {
#   ragg::agg_png(
#     filename = here::here("figures", paste0("heatmap", plot_name, ".png")),
#     width = 1800,
#     height = nrows * 35 + 200,
#     res = 300
#   )
#   plot
#   dev.off()
# }
#
# pmap(
#   .l = list(plot = heatmapAppendixList,
#   plot_name = c("Large", "MedSm", "Non"),
#   nrows = c(434, 728, 1965)),
#   .f = ~ saveHeatmap(plot = ..1, plot_name = ..2, nrows = ..3)
# )
```

# Geofacet relative excess line graphs

Note: Line graphs only depict counties with > 15k population


```{r geofacet data prep}
plotDataState <- monthlyEstimatesState %>%
  filter(monthYear >= date("2020-03-01"), monthYear <= date("2022-02-01"))

plotDataGeofacet <- plotData %>%
  mutate(plotGroup = "Individual counties") %>%
  # remove small counties for clearer visualization
  filter(pop > 15000) %>%
  bind_rows(plotDataState) %>%
  mutate(plotGroup = coalesce(plotGroup, "State total"))
```

```{r geofacet plot, include=TRUE}
gGeofacet <- ggplot(
  plotDataGeofacet,
  aes(
    x = monthYear,
    y = relExcDeathsMed * 100,
    # linetype = metroStatus,
    group = countyName,
    color = plotGroup,
    alpha = plotGroup
  )
)

(geofacetOut <- gGeofacet +
  geom_hline(
    yintercept = 0,
    color = "grey40",
    linewidth = .2
  ) +
  geom_line(
    # color = "grey10",
    linewidth = .3
  ) +
  scale_alpha_discrete(
    range = c(.21, 1)
  ) +
  scale_color_discrete_diverging(
    palette = "Vik",
    rev = TRUE,
    nmax = 10,
    order = c(4, 10)
  ) +
  scale_x_date(
    # expand = c(0, 0),
    breaks = scales::breaks_width(width = "12 months"),
    minor_breaks = scales::breaks_width(width = "3 months"),
    labels = scales::label_date_short(),
    guide = "axis_minor"
  ) +
  scale_y_continuous(
    # expand = c(0, 0),
    oob = scales::oob_keep,
    breaks = c(seq.int(-100, 200, 50))
  ) +
  coord_cartesian(
    ylim = c(-50, 200),
    expand = FALSE,
    clip = "off"
  ) +
  facet_geo(
    facets = ~state,
    grid = us_state_grid_custom
  ) +
  labs(
    y = "Relative excess mortality (%)",
    x = NULL,
    color = NULL,
    linetype = NULL,
    alpha = NULL
  ) +
  guides(
    color = "legend",
    alpha = "none"
  ) +
  theme_minimal2 +
  theme(
    text = element_text(size = 9),
    panel.border = element_rect(fill = "transparent"),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_line(),
    axis.ticks = element_line(),
    axis.ticks.length = unit(3.5, "points"),
    ggh4x.axis.ticks.length.minor = rel(.61),
    legend.direction = "vertical",
    legend.position = c(0, 0),
    legend.justification = "left"
  )
)
```
```{r export geofacet}
# ragg::agg_png(
#   filename = here::here("figures", "geofacet.png"),
cairo_pdf(
  filename = here::here("figures", "figure8_geofacet.pdf"),
  width = 9,
  height = 6.25
)
geofacetOut
dev.off()
```

# "Cumulative" Excess Deaths
```{r cumulative excess data prep}
plotCumulative <- plotDataHeatmap %>%
  arrange(census_region, metroCat2, monthYear) %>%
  group_by(census_region, metroCat2, monthYear) %>%
  summarize(
    across(
      # despite summarizing all of these variables, really only observed values and mean estimates should be aggregated
      c(
        COVIDDeaths,
        deaths,
        expDeathsMean:excDeathsUp
      ),
      sum,
      na.rm = TRUE
    ),
    .groups = "drop"
  ) %>%
  group_by(census_region, metroCat2) %>%
  mutate(
    across(
      c(
        COVIDDeaths,
        deaths,
        expDeathsMean:excDeathsUp
      ),
      ~ with_order(monthYear, cumsum, .x),
      .names = "{.col}Cumulative"
    ),
    excDeathsRelativeMedCumulative = excDeathsMedCumulative / expDeathsMedCumulative * 100,
    excDeathsRelativeMeanCumulative = excDeathsMeanCumulative / expDeathsMeanCumulative * 100,
    significantCumulative = excDeathsLow > 0,
    metroAbbr = str_replace_all(
      metroCat2,
      c(
        "Large" = "Lrg",
        "Medium or Small" = "Med/sm"
      )
    ),
    label = as.character(
      glue::glue(
        "{census_region} – {metroCat2}"
      )
    ),
    labelPoint = as.character(
      glue::glue(
        "{census_region}\n{metroAbbr}"
      )
    )
  ) %>%
  ungroup() %>%
  mutate(
    labelMargin = if_else(
      monthYear == max(monthYear),
      label,
      NA_character_
    ),
    labelMarginLeft = if_else(
      monthYear == min(monthYear),
      label,
      NA_character_
    ),
    labelPointTop = if_else(
      census_region == "Northeast" &
        metroCat2 == "Large metro" &
        monthYear == ymd("2020-04-01"),
      labelPoint,
      NA_character_
    ),
    labelPointBottom = if_else(
      (
        census_region == "Midwest" &
          metroCat2 == "Large metro" &
          monthYear == ymd("2020-05-01")
      ) |
        (
          census_region == "Midwest" &
            metroCat2 == "Large metro" &
            monthYear %in% c(
              ymd("2020-05-01")
            )
        ) |
        (
          census_region == "Northeast" &
            metroCat2 == "Medium or small metro" &
            monthYear %in% c(
              ymd("2020-05-01")
            )
        ),
      labelPoint,
      NA_character_
    ),
    pointForLabel = !(is.na(labelPointTop) & is.na(labelPointBottom))
  )
```
```{r cumulative excess plot, include=TRUE}
gExcessCumulative <- ggplot(
  plotCumulative,
  aes(
    x = monthYear,
    y = excDeathsRelativeMeanCumulative,
    color = census_region,
    linetype = metroCat2
  )
)

excessCumulative <- gExcessCumulative +
  geom_line(
    linewidth = .5
  ) +
  scale_color_manual(values = colorscaleCumulative) +
  scale_linetype_manual(values = linetypeCumulative) +
  scale_x_date(
    breaks = scales::breaks_width(width = "1 months"),
    minor_breaks = scales::breaks_width(width = "1 months"),
    labels = scales::label_date_short(),
    guide = "axis_minor",
    oob = scales::oob_keep
  ) +
  scale_y_continuous(
    trans = scales::pseudo_log_trans(base = 10, sigma = 5),
    breaks = c(0, 1, 5, 10, 25, 50, 75, 100)
  ) +
  coord_cartesian(
    ylim = c(-.5, 100),
    expand = FALSE,
    clip = "on"
  ) +
  labs(
    y = "Relative excess mortality (%)",
    x = NULL,
    color = "group",
    linetype = "group"
  ) +
  guides(
    color = "none",
    linetype = "none",
    fill = "none",
    label = "none"
  ) +
  theme_minimal2 +
  theme(
    text = element_text(size = 9),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_line(),
    axis.ticks = element_line(),
    axis.ticks.length = unit(3.5, "points"),
    ggh4x.axis.ticks.length.minor = rel(.61)
  )

excessCumulativeLabelMargin <- gExcessCumulative +
  geom_text_repel(
    aes(label = labelMargin),
    size = 2.5,
    segment.size = .3,
    segment.linetype = "16",
    min.segment.length = 0,
    direction = "y",
    hjust = 0,
    force_pull = .2,
    xlim = c(ymd("2022-02-02"), Inf),
    seed = 20230331,
    show.legend = FALSE,
    max.overlaps = 40
  ) +
  scale_y_continuous(
    trans = scales::pseudo_log_trans(base = 10, sigma = 5)
  ) +
  scale_x_date() +
  coord_cartesian(
    ylim = c(-.5, 100),
    xlim = c(ymd("2022-02-01"), ymd("2022-02-10")),
    expand = FALSE,
    clip = "off"
  ) +
  scale_color_manual(values = colorscaleCumulative) +
  labs(
    y = NULL,
    x = NULL,
    color = NULL
  ) +
  theme_void()

legendDF <- crossing(
  census_division = c("Midwest", "Northeast", "South", "West"),
  metroCat2 = c("Large metro", "Medium or small metro", "Nonmetro")
) %>%
  mutate(
    y = as.integer(as_factor(metroCat2)),
    x = as.integer(as_factor(census_division)) * 3.25 - 2.25
  )

gLegend <- ggplot(
  legendDF,
  aes(
    x = x - .5,
    xend = x + .5,
    y = y + .5,
    yend = y - .5,
    color = census_division,
    linetype = metroCat2
  )
) +
  geom_segment() +
  geom_label(
    aes(
      x = x,
      label = stringr::str_wrap(census_division, width = 12)
    ),
    y = 0,
    hjust = .5,
    size = 2.5,
    label.size = 0
  ) +
  geom_label(
    aes(
      y = y,
      label = stringr::str_wrap(metroCat2, width = 12)
    ),
    x = 12,
    color = "grey10",
    hjust = 0,
    vjust = .5,
    size = 2.5,
    label.size = 0
  ) +
  scale_color_manual(values = colorscaleCumulative) +
  scale_linetype_manual(values = linetypeCumulative) +
  scale_y_continuous(
    trans = "reverse"
  ) +
  coord_cartesian(
    clip = "off",
    xlim = c(NA, 13)
  ) +
  guides(
    color = "none",
    linetype = "none",
    label = "none"
  ) +
  theme_void() +
  theme(
    plot.margin = unit(c(0, 0, 0, 0), "points"),
    panel.background = element_rect(fill = "white", color = "white"),
    plot.background = element_rect(fill = "white", color = "white")
  )

layout <- c(
  # plot
  area(t = 1, l = 1, b = 13, r = 8),
  # margin labels
  area(t = 1, l = 9, b = 13, r = 11),
  # legend
  area(t = 2, l = 5, b = 4, r = 7)
)

(
  excessCumulativeOut <- excessCumulative +
    excessCumulativeLabelMargin +
    gLegend +
    plot_layout(design = layout)
)
```
```{r export cumulative excess}
exportWidth <- 7.8
exportHeight <- 4.55
exportName <- "figure5_excessCumulative"

cairo_pdf(
  filename = here::here("figures", paste0(exportName, ".pdf")),
  width = exportWidth,
  height = exportHeight
)
excessCumulativeOut
dev.off()

ragg::agg_png(
  filename = here::here("figures", paste0(exportName, ".png")),
  width = exportWidth,
  height = exportHeight,
  units = "in",
  res = 300
)
excessCumulativeOut
dev.off()
```

# COVID vs non-COVID excess
## facet line graphs
```{r excess v covid data prep}
metroDivisionMonthPopRates <- metroDivisionMonth %>% 
  mutate(
    across(
      c(totalCOVIDDeaths:excNCCumulativeUp),
    .fns = c(
      `100k` = ~ 100000 * .x / pop
    )
  ),
  census_region = case_when(
      census_division %in% c("Mountain", "Pacific") ~ "West",
      census_division %in% c("East North Central", "West North Central") ~ "Midwest",
      census_division %in% c("Middle Atlantic", "New England") ~ "Northeast",
      census_division %in% c("East South Central", "South Atlantic", "West South Central") ~ "South"
    )
  )

metroDivisionMonthPopLong <- metroDivisionMonthPopRates %>% 
  pivot_longer(
    cols = c(
      matches("(totalCOVIDDeaths_|excMed_|excNCMed_)") & 
        ends_with("_100k")
      ),
    names_to = "outcome"
  )
```

```{r excess v covid plot}
excessVsCOVIDPlot <- metroDivisionMonthPopLong %>%
  ggplot(
    aes(
      x = monthYear,
      y = value,
      color = outcome,
      linetype = outcome
    )
  ) +
  geom_hline(
      yintercept = 0,
      color = "grey50",
      linewidth = .2
    ) +
  geom_ribbon(
    aes(
      ymin = excLow_100k,
      ymax = excUp_100k
    ),
    fill = colorscaleVik10[6],
    color = "transparent"
  ) +
  geom_line() +
  scale_color_manual(
    values = c(colorscaleVik10[10], "grey30", colorscaleVik10[2]),
    labels = c(
      "Excess deaths",
      "Non-COVID-19 excess deaths",
      "COVID-19 deaths"
    )
  ) +
  scale_linetype_manual(
    values = linetypeCumulative[c(1, 3, 2)],
     labels = c(
      "Excess deaths",
      "Non-COVID-19 excess deaths",
      "COVID-19 deaths"
    )
  ) +
  scale_x_date(
    breaks = scales::breaks_width(width = "3 months"),
    minor_breaks = scales::breaks_width(width = "1 months"),
    labels = scales::label_date_short(),
    guide = "axis_minor",
    expand = c(0, 0)
  ) +
  scale_y_continuous(breaks = seq.int(0, 150, 25)) +
  labs(
    y = 'Deaths per 100,000 residents',
    x = NULL,
    linetype = NULL
  ) +
  facet_nested(
    rows = vars(census_region, census_division),
    cols = vars(metroCat3),
    space = "free_y", 
    scales = "free_y",
    nest_line = element_line(),
    labeller = labeller(
      .rows = label_wrap_gen(12)
    ),
    strip = strip_nested(
      text_y = list(
        # element_text(vjust = 0),
        element_text(
      angle = 0,
      hjust = 0
    )
    ),
      by_layer_y = TRUE
    )
  ) +
  guides(
    fill = "none",
    linetype = guide_legend(
      title = NULL
    ),
    color = guide_legend(
      title = NULL,
      override.aes = list(fill = "transparent")
    )
  ) +
  theme_minimal2 +
  theme(
    text = element_text(size = 12),
    panel.border = element_rect(fill = "transparent"),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_line(),
    axis.ticks = element_line(),
    axis.ticks.length = unit(3.5, "points"),
    ggh4x.axis.ticks.length.minor = rel(.61),
    legend.direction = "horizontal",
    legend.position = "bottom",
    legend.margin = margin(0, 0, 0, 0, unit = "cm"),
    legend.box.margin = margin(0, 0, 0, 0, unit = "cm")
  )
```

```{r export excess v covid}
exportWidth <- 10
exportHeight <- 14
exportName <- "excessVsCOVIDPlot"

cairo_pdf(
  filename = here::here("figures", paste0(exportName, ".pdf")),
  width = exportWidth,
  height = exportHeight
)
excessVsCOVIDPlot
dev.off()

ragg::agg_png(
  filename = here::here("figures", paste0(exportName, ".png")),
  width = exportWidth,
  height = exportHeight,
  units = "in",
  res = 300
)
excessVsCOVIDPlot
dev.off()
```

# Cumulative COVID vs cumulative excess
## metro-division facet line graphs
```{r cumulative excess vs covid plot}
gExcessVsCovidFacetCumulative <- ggplot(
  metroDivisionMonthPopRates,
  aes(
    x = monthYear
  )
)

(excessVsCovidFacetCumulativeOut <- gExcessVsCovidFacetCumulative +
  # geom_hline(
  #   yintercept = 0,
  #   color = "grey40",
  #   linewidth = .2
  # ) +
  ggh4x::stat_difference(
    aes(
      ymax = totalCOVIDDeathsCumulative_100k,
      ymin = excCumulativeMed_100k
    ),
    levels = c(
      "COVID-19 mortality > natural-cause excess mortality",
      "Natural-cause excess mortality > COVID-19 mortality",
      NA
    ),
    alpha = .75
  ) +
  geom_line(
    aes(
      y = excCumulativeMed_100k,
      color = "Natural-cause excess deaths (cumulative)",
      linetype = "Natural-cause excess deaths (cumulative)"
    ),
    linewidth = .3
  ) +
  geom_line(
    aes(
      y = totalCOVIDDeathsCumulative_100k,
      color = "Reported COVID-19 deaths (cumulative)",
      linetype = "Reported COVID-19 deaths (cumulative)"
    ),
    linewidth = .3
  ) +
  scale_color_discrete_diverging(
    palette = "Vik",
    rev = TRUE,
    nmax = 2
  ) +
  scale_fill_discrete_diverging(
    palette = "Vik",
    rev = FALSE,
    nmax = 10,
    order = c(5, 6),
    na.translate = FALSE
  ) +
  scale_linetype_manual(values = linetypeCumulative[c(1:2)]) +
  scale_x_date(
    breaks = scales::breaks_width(width = "3 months"),
    minor_breaks = scales::breaks_width(width = "1 months"),
    labels = scales::label_date_short(),
    guide = "axis_minor",
    expand = c(0, 0)
) +
  coord_cartesian(
    ylim = c(0, NA),
    expand = FALSE,
    clip = "off"
  ) +
    facet_nested(
    rows = vars(census_region, census_division),
    cols = vars(metroCat3),
    space = "free_y", 
    scales = "free_y",
    nest_line = element_line(),
    labeller = labeller(
      .rows = label_wrap_gen(12)
    ),
    strip = strip_nested(
      text_y = list(
        # element_text(vjust = 0),
        element_text(
      angle = 0,
      hjust = 0
    )
    ),
      by_layer_y = TRUE
    )
  ) +
  labs(
    y = "Deaths per 100,000 residents (cumulative)",
    x = NULL,
    color = NULL,
    linetype = NULL,
    fill = NULL
  ) +
  guides(
    linetype = guide_legend(
            title = NULL,
            nrow = 2
        ),
        color = guide_legend(
            title = NULL,
            nrow = 2,
            override.aes = list(fill = "transparent")
        ),
    fill = guide_legend(
      reverse = TRUE,
      nrow = 2,
      override.aes = list(
        color = "grey40",
        linewidth = .2
      )
    )
  ) +
  theme_minimal2 +
    theme(
        text = element_text(size = 12),
        panel.border = element_rect(fill = "transparent"),
        panel.grid.minor = element_blank(),
        panel.grid.major = element_line(),
        axis.ticks = element_line(),
        axis.ticks.length = unit(3.5, "points"),
        ggh4x.axis.ticks.length.minor = rel(.61),
        strip.text.y = element_text(
            angle = 0,
            hjust = 0
        ),
        legend.direction = "horizontal",
        legend.position = "bottom",
        legend.margin = margin(0, 0, 0, 0, unit = "cm"),
        legend.box.margin = margin(0, 0, 0, 0, unit = "cm")
    )
)
```
```{r export cumulative excess v covid}
exportWidth <- 10
exportHeight <- 14
exportName <- "excess_vs_covid_cumulative_facet"

cairo_pdf(
  filename = here::here("figures", paste0(exportName, ".pdf")),
  width = exportWidth,
  height = exportHeight
)
excessVsCovidFacetCumulativeOut
dev.off()

ragg::agg_png(
  filename = here::here("figures", paste0(exportName, ".png")),
  width = exportWidth,
  height = exportHeight,
  units = "in",
  res = 300
)
excessVsCovidFacetCumulativeOut
dev.off()
```

## geofacet
```{r cumulative covid vs excess geofacet plot}
gCOVIDGeofacet <- ggplot(
  stateMonthCumulative,
  aes(
    x = monthYear
  )
)

(geofacetCOVIDOut <- gCOVIDGeofacet +
  # geom_hline(
  #   yintercept = 0,
  #   color = "grey40",
  #   linewidth = .2
  # ) +
  ggh4x::stat_difference(
    aes(
      ymax = COVIDCumulativeRelMed,
      ymin = excCumulativeRelMed
    ),
    levels = c(
      "COVID-19 mortality > natural-cause excess mortality",
      "Natural-cause excess mortality > COVID-19 mortality",
      NA
    ),
    alpha = .75
  ) +
  geom_line(
    aes(
      y = excCumulativeRelMed,
      color = "Natural-cause relative excess deaths (cumulative)",
      linetype = "Natural-cause relative excess deaths (cumulative)"
    ),
    linewidth = .3
  ) +
  geom_line(
    aes(
      y = COVIDCumulativeRelMed,
      color = "Relative COVID-19 deaths (cumulative)",
      linetype = "Relative COVID-19 deaths (cumulative)"
    ),
    linewidth = .3
  ) +
  scale_color_discrete_diverging(
    palette = "Vik",
    rev = TRUE,
    nmax = 2
  ) +
  scale_fill_discrete_diverging(
    palette = "Vik",
    rev = FALSE,
    nmax = 10,
    order = c(5, 6),
    na.translate = FALSE
  ) +
  scale_linetype_manual(values = linetypeCumulative[c(1:2)]) +
  scale_x_date(
    # expand = c(0, 0),
    breaks = scales::breaks_width(width = "12 months"),
    minor_breaks = scales::breaks_width(width = "3 months"),
    labels = scales::label_date_short(),
    guide = "axis_minor"
  ) +
  # scale_y_continuous(
  #   # expand = c(0, 0),
  #   oob = scales::oob_keep,
  #   breaks = c(seq.int(-100, 200, 50))
  # ) +
  coord_cartesian(
    ylim = c(0, 30),
    expand = FALSE,
    clip = "off"
  ) +
  facet_geo(
    facets = ~state,
    grid = us_state_grid_custom
  ) +
  labs(
    y = "Mortality relative to total expected deaths (%)",
    x = NULL,
    color = NULL,
    linetype = NULL,
    fill = NULL
  ) +
  guides(
    color = guide_legend(nrow = 2),
    linetype = guide_legend(
      override.aes = list(
        size = .4
      )
    ),
    fill = guide_legend(
      reverse = TRUE,
      nrow = 2,
      override.aes = list(
        color = "grey40",
        linewidth = .2
      )
    )
  ) +
  theme_minimal2 +
  theme(
    text = element_text(size = 9),
    panel.border = element_rect(fill = "transparent"),
    # plot.margin = margin(0, 0, .5, 0, unit = "cm"),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_line(),
    axis.ticks = element_line(),
    axis.ticks.length = unit(3.5, "points"),
    ggh4x.axis.ticks.length.minor = rel(.61),
    legend.direction = "horizontal",
    legend.position = "bottom",
    # legend.position = c(0, 0),
    # legend.justification = c("left", "bottom"),
    legend.margin = margin(0, 0, 0, 0, unit = "cm"),
    legend.box.margin = margin(0, 0, 0, 0, unit = "cm"),
    legend.key.size = unit(.61, "cm")
  )
)
```
```{r export cumulative covid geofacet}
exportWidth <- 9
exportHeight <- 6.25
exportName <- "covid_vs_excess_cumalitve_geofacet"

cairo_pdf(
  filename = here::here("figures", paste0(exportName, ".pdf")),
  width = exportWidth,
  height = exportHeight
)
geofacetCOVIDOut
dev.off()

ragg::agg_png(
  filename = here::here("figures", paste0(exportName, ".png")),
  width = exportWidth,
  height = exportHeight,
  units = "in",
  res = 300
)
geofacetCOVIDOut
dev.off()
```

## region-metro ratio

```{r cumulative covid-excess ratio region data prep}
plotMetroRegionMonth <- metroRegionMonth %>%
  filter(
    excCumulativeMed > 100,
    totalCOVIDDeathsCumulative > 100
  ) %>% 
  mutate(
    metroAbbr = str_replace_all(
      metroCat3,
      c(
        "Large" = "Lrg",
        "Medium or Small" = "Med/sm"
      )
    ),
    label = as.character(
      glue::glue(
        "{census_region} – {metroCat3}"
      )
    ),
    labelPoint = as.character(
      glue::glue(
        "{census_region}\n{metroAbbr}"
      )
    )
  ) %>%
  ungroup() %>%
  mutate(
    labelMargin = if_else(
      monthYear == max(monthYear),
      label,
      NA_character_
    ),
    labelMarginLeft = if_else(
      monthYear == min(monthYear),
      label,
      NA_character_
    )
  )

plotMetroRegionMonthLastObs <- plotMetroRegionMonth %>% 
  filter(monthYear == max(monthYear))
```
```{r cumulative covid-excess ratio region plot, include=TRUE}
gExcessCOVIDRatioCumulative <- ggplot(
  plotMetroRegionMonth,
  aes(
    x = monthYear,
    y = excessCOVIDRatioCumulativeMed,
    color = census_region,
    fill = census_region,
    linetype = metroCat3
  )
)

excessCOVIDRatioCumulativePlot <- gExcessCOVIDRatioCumulative +
  geom_line(
    linewidth = .5
  ) +
  geom_point(
    data = plotMetroRegionMonthLastObs,
    shape = 23,
    color = "white",
    stroke = .1
  ) +
  scale_color_manual(values = colorscaleCumulative) +
  scale_fill_manual(values = colorscaleCumulative) +
  scale_linetype_manual(values = linetypeCumulative) +
  scale_x_date(
    breaks = scales::breaks_width(width = "3 months"),
    minor_breaks = scales::breaks_width(width = "1 months"),
    labels = scales::label_date_short(),
    guide = "axis_minor",
    oob = scales::oob_keep
  ) +
  scale_y_continuous(
    trans = scales::pseudo_log_trans(base = 2, sigma = .61),
    breaks = seq(0, 5, .5)
  ) +
  coord_cartesian(
    ylim = c(0, 5),
    expand = FALSE,
    clip = "off"
  ) +
  labs(
    y = "Ratio of excess deaths to reported COVID-19 deaths (cumulative)",
    x = NULL,
    color = "group",
    linetype = "group"
  ) +
  guides(
    color = "none",
    linetype = "none",
    fill = "none",
    label = "none"
  ) +
  theme_minimal2 +
  theme(
    text = element_text(size = 9),
    panel.grid.minor = element_blank(),
    panel.grid.major = element_line(),
    axis.ticks = element_line(),
    axis.ticks.length = unit(3.5, "points"),
    ggh4x.axis.ticks.length.minor = rel(.61)
  )

excessCOVIDRatioCumulativeLabelMargin <- gExcessCOVIDRatioCumulative +
  geom_text_repel(
    aes(label = labelMargin),
    size = 2.5,
    segment.size = .3,
    segment.linetype = "16",
    min.segment.length = 0,
    direction = "y",
    hjust = 0,
    force_pull = .2,
    xlim = c(ymd("2022-08-02"), Inf),
    seed = 20230331,
    show.legend = FALSE,
    max.overlaps = 40
  ) +
  scale_x_date() +
  scale_y_continuous(
    trans = scales::pseudo_log_trans(base = 2, sigma = .61),
    breaks = seq(0, 5, .5)
  ) +
  coord_cartesian(
    ylim = c(0, 5),
    xlim = c(ymd("2022-08-01"), ymd("2022-08-10")),
    expand = FALSE,
    clip = "off"
  ) +
  scale_color_manual(values = colorscaleCumulative) +
  labs(
    y = NULL,
    x = NULL,
    color = NULL
  ) +
  theme_void()

legendDF <- crossing(
  census_division = c("Midwest", "Northeast", "South", "West"),
  metroCat3 = c("Large metro", "Medium or small metro", "Nonmetro")
) %>%
  mutate(
    y = as.integer(as_factor(metroCat3)),
    x = as.integer(as_factor(census_division)) * 3.25 - 2.25
  )

gLegend <- ggplot(
  legendDF,
  aes(
    x = x - .5,
    xend = x + .5,
    y = y + .5,
    yend = y - .5,
    color = census_division,
    linetype = metroCat3
  )
) +
  geom_segment() +
  geom_label(
    aes(
      x = x,
      label = stringr::str_wrap(census_division, width = 12)
    ),
    y = 0,
    hjust = .5,
    size = 2.5,
    label.size = 0
  ) +
  geom_label(
    aes(
      y = y,
      label = stringr::str_wrap(metroCat3, width = 12)
    ),
    x = 12,
    color = "grey10",
    hjust = 0,
    vjust = .5,
    size = 2.5,
    label.size = 0
  ) +
  scale_color_manual(values = colorscaleCumulative) +
  scale_linetype_manual(values = linetypeCumulative) +
  scale_y_continuous(
    trans = "reverse"
  ) +
  coord_cartesian(
    clip = "off",
    xlim = c(NA, 13)
  ) +
  guides(
    color = "none",
    linetype = "none",
    label = "none"
  ) +
  theme_void() +
  theme(
    plot.margin = unit(c(0, 0, 0, 0), "points"),
    panel.background = element_rect(fill = "white", color = "white"),
    plot.background = element_rect(fill = "white", color = "white")
  )

layout <- c(
  # plot
  area(t = 1, l = 1, b = 13, r = 8),
  # margin labels
  area(t = 1, l = 9, b = 13, r = 11),
  # legend
  area(t = 2, l = 5, b = 4, r = 7)
)

(
  excessCOVIDRatioCumulativeOut <- excessCOVIDRatioCumulativePlot +
    excessCOVIDRatioCumulativeLabelMargin +
    gLegend +
    plot_layout(design = layout)
)
```
```{r export cumulative ratio}
exportWidth <- 7.8
exportHeight <- 4.55
exportName <- "cumulative_excess_to_covid_ratio"

cairo_pdf(
  filename = here::here("figures", paste0(exportName, ".pdf")),
  width = exportWidth,
  height = exportHeight
)
excessCOVIDRatioCumulativeOut
dev.off()

ragg::agg_png(
  filename = here::here("figures", paste0(exportName, ".png")),
  width = exportWidth,
  height = exportHeight,
  units = "in",
  res = 300
)
excessCOVIDRatioCumulativeOut
dev.off()
```
