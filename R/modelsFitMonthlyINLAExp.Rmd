---
title: "County-Level Mortality Models - Estimation"
author: "Eugenio Paglino"
date: "\today"
output:
  html_document:
    df_print: paged
---

```{r, message=F,warning=F}

# Loading necessary packages

library(lubridate)
library(USAboundaries)
library(sf)
library(spdep)
library(INLA)
library(here)
library(tidyverse)

```

```{r, echo=FALSE, message=F, warning=F}

rm(list=ls())

here::i_am('R/modelsFitMonthly.Rmd')

inDir <- here::here('data','input')
outDir <- here::here('data','output')

set.seed(42)

```

```{r, echo=F}

ACData <- tibble(arrow::read_feather(here::here(outDir,'ACData.feather')))

allFIPS <- ACData %>% pull(FIPSCode) %>% unique()
allStates <- ACData %>% pull(stateFIPS) %>% unique()

ACData <- ACData %>%
  filter(stateFIPS %in% sample(stateFIPS,10,replace=T))

```

```{r}

counties <- us_counties()
# Transform to Albers for making map of US
counties <- st_transform(counties, 5070)

counties <- counties %>%
  select(geoid,geometry) %>%
  rename(FIPSCode = geoid) %>%
  mutate(FIPSCode = case_when(FIPSCode == '02013' ~ '02010',
                              FIPSCode == '02188' ~ '02140',
                              FIPSCode == '02230' ~ '02232',
                              FIPSCode == '02063' ~ '02261',
                              TRUE ~ FIPSCode)) %>%
  filter(FIPSCode %in% unique(ACData %>% pull(FIPSCode))) %>%
  arrange(FIPSCode)

```

```{r}

neighbors <- poly2nb(counties)

# We can edit neighbors manually but we need to be very careful because
# neighborhood is here a symmetric relationship so that everything breaks
# (in INLA) if A is B's neighbor. but B is not A's neighbor.

#neighbors[[68]] <- as.integer(c(70))
#neighbors[[71]] <- as.integer(c(70))
#neighbors[[70]] <- sort(as.integer(c(neighbors[[70]], 68, 71)))

nb2INLA(here::here(outDir,'neighborsEx.graph'),neighbors)
inla.graph <- inla.read.graph(here::here(outDir,'neighborsEx.graph'))
adj.matrix <- inla.graph2matrix(inla.graph)

```

```{r, warning=F, message=F}

neighbors_sf <- as(nb2lines(neighbors, coords = coordinates(as(counties,'Spatial'))), 'sf')
neighbors_sf <- st_set_crs(neighbors_sf, st_crs(counties))

counties %>%
  ggplot() + 
    geom_sf(fill = 'salmon', color = 'white') +
    geom_sf(data = neighbors_sf) +
    theme_minimal()

```

```{r, echo=F}

ACData <- ACData %>%
  group_by(FIPSCode) %>%
  mutate(FIPSCode = cur_group_id(),
         FIPSCode2 = FIPSCode,
         FIPSCode3 = FIPSCode,
         FIPSCode4 = FIPSCode) %>%
  ungroup() %>%
  group_by(year,month) %>%
  mutate(timeID = cur_group_id()) %>%
  ungroup() %>%
  mutate(quarter = floor((timeID -1)/ 4) + 1) %>%
  group_by(census_division) %>%
  mutate(divisionID = cur_group_id()) %>%
  ungroup() %>%
  group_by(year) %>%
  mutate(yearID = cur_group_id(),
         yearID2 = yearID) %>%
  ungroup() %>%
  mutate(CDRCensored = if_else(year>2019,NA_real_,CDR),
         deathsCensored = if_else(year>2019,NA_integer_,deaths)) %>%
  arrange(FIPSCode,year,month)

```

```{r}
# Function to compute the Root Mean Squared Error (RMSE) between two series
RMSE <- function(series1,series2) {
  
  return(sqrt(mean((series1 - series2)^2,na.rm=T)))
  
}
```

```{r}

# INLA SET UP
# priors
hyper.bym <- list(prec.unstruct=list(param=c(1,0.1)),
                  prec.spatial=list(param=c(1,0.1)))
hyper.iid <- list(theta = list(prior="pc.prec", param=c(1, 0.01)))

formula <- deathsCensored ~ 1 + offset(log(pop)) + as.factor(month) +
                                f(FIPSCode, model='bym', hyper=hyper.bym,
                                  graph=inla.graph, scale.model=T) +
                                f(yearID, model='iid',hyper=hyper.iid) +
                                f(FIPSCode2,yearID2,model='iid',hyper = hyper.iid) +
                                f(quarter, model='rw1',hyper=hyper.iid,scale.model = T)
                                
# Under Poisson uses default set up
control.family=inla.set.control.family.default()

```

```{r}

# We re-estimated the last model with INLA so that we can use it to 
# build posterior intervals for the predictions.

model.BYM.LinearTime.INLA <- ACData %>%
  mutate(deathsCensored = if_else(year>=2019,NA_integer_,deathsCensored)) %>%
  inla(formula,
       data = .,
       family = "poisson",
       num.threads = round(parallel::detectCores()*0.7),
       control.family=control.family,
       control.compute=list(config = TRUE))

# Note: INLA is a bit tricky, error messages are not very informative.

```

```{r}

n.sim <- 1000
draws <- inla.posterior.sample(n.sim, model.BYM.LinearTime.INLA)
model.names <- row.names(draws[[1]]$latent)
y.names <- grep("Predictor", model.names)

rate.draws <- sapply(draws, function(x) exp(x$latent[y.names]))
death.draws <- t(apply(rate.draws,M=1,function(x) rpois(n.sim,x)))
mean.deaths <- apply(death.draws,M=1,function(x) mean(x))
up.deaths <- apply(death.draws,M=1,function(x) quantile(x,0.95))
low.deaths <- apply(death.draws,M=1,function(x) quantile(x,0.05))

```

```{r}

testData <- tibble(deaths = pull(ACData,deaths),
                   CDR = pull(ACData,CDR),
                   pop = pull(ACData,pop),
                   FIPSCode = pull(ACData,FIPSCode),
                   year = pull(ACData,year),
                   month = pull(ACData,month))

testData <- testData %>% 
  mutate(expDeathsMean = mean.deaths,
         expDeathsUp = up.deaths,
         expDeathsLow = low.deaths,
         expRateMean = (mean.deaths/pop)*100000,
         expRateUp = (up.deaths/pop)*100000,
         expRateLow = (low.deaths/pop)*100000,
         monthYear = make_date(year,month,1))

```

```{r}

RMSE(testData %>% filter(year<2019) %>% pull(expDeathsMean),
     testData %>% filter(year<2019) %>% pull(deaths))

RMSE(testData %>% filter(year==2019) %>% pull(expDeathsMean),
     testData %>% filter(year==2019) %>% pull(deaths))

RMSE(testData %>% filter(year<2020) %>% pull(expDeathsMean),
     testData %>% filter(year<2020) %>% pull(deaths))

```

```{r}

# Good for overfitting: c(12,15,21,47,86,13)
# Good for trend: c(1,17,63,71,75,91)
# Hard to predict: 37,64
# To examine: c(481,496,528,206)

# Examples: c(1,58,89,93)

numFIPS <- length(unique(pull(ACData,FIPSCode)))

testFigure <- testData %>%
  filter(FIPSCode %in% sample(1:numFIPS,6)) %>%
  ggplot() +
  geom_line(mapping=aes(x=monthYear,y=CDR,color='Observed')) +
  geom_line(mapping=aes(x=monthYear,y=expRateMean,color='Expected')) +
  geom_ribbon(mapping=aes(x=monthYear,ymin=expRateLow,ymax=expRateUp,
                          fill='Expected'),alpha=0.3) +
  labs(x='Deaths',
       y='',
       color='',
       fill='') +
  facet_wrap(~FIPSCode) +
  guides(fill='none')

testFigure

```
```{r}

pdf(here::here('figures',"examples.pdf"), width = 12, height = 8,)

testFigure

dev.off()

```



```{r, eval=F}

# c(40,5)

testData %>%
  filter(FIPSCode %in% c(40,5)) %>%
  ggplot() +
  geom_line(mapping=aes(x=monthYear,y=deaths-expDeathsMean,color='Observed')) +
  geom_hline(yintercept=0) +
  geom_vline(xintercept=make_date(2018,12,31)) +
  facet_wrap(~FIPSCode)

```

```{r}

timeParams <- sapply(draws, function(x) x$latent[grep("FIPSCode2",rownames(x$latent))])
timeParamsMeans <- apply(timeParams,M=1, function(x) mean(x))
plot(timeParamsMeans)

```

```{r}

timeParams <- sapply(draws, function(x) x$latent[grep("quarter",rownames(x$latent))])
timeParamsMeans <- apply(timeParams,M=1, function(x) mean(x))
timeParamsLow <- apply(timeParams,M=1, function(x) quantile(x,0.025))
timeParamsUp <- apply(timeParams,M=1, function(x) quantile(x,0.975))

ggplot() +
  geom_line(mapping=aes(x=1:length(timeParamsMeans),y=timeParamsMeans)) +
  geom_ribbon(mapping=aes(x=1:length(timeParamsLow),ymin=timeParamsLow,ymax=timeParamsUp),
              alpha=0.2)

```

```{r}

timeParams <- sapply(draws, function(x) x$latent[grep("month",rownames(x$latent))])
timeParamsMeans <- apply(timeParams,M=1, function(x) mean(x))
plot(timeParamsMeans,type='l')

```

```{r}

timeParams <- sapply(draws, function(x) x$latent[grep("yearID",rownames(x$latent))])
timeParamsMeans <- apply(timeParams,M=1, function(x) mean(x))
plot(timeParamsMeans,type='l')

```


```{r}

acf(drop_na(filter(testData,year<2019))$deaths - drop_na(filter(testData,year<2019))$expDeathsMean)

```

```{r}

n.sim <- 1000
coef <- 1
ARMean <- 0
arProcess <- rep(0,n.sim)
errors <-  rnorm(n.sim,ARMean,0.5)

for (i in 4:n.sim) {
  
  arProcess[i] <- coef*arProcess[i-1] + errors[i]
  
}

plot(arProcess,type='l')
lines(errors,col='red')

```

```{r}

n=100
z=seq(0,6,length.out=n)
y=sin(z)+rnorm(n,mean=0,sd=1)+seq(0,5,length.out=100)
y[90:n] <- NA
data=data.frame(y=y,z=z)
formula=y~f(z,model="rw1",
hyper = list(prec = list(prior="loggamma",param=c(1,0.01))))
result=inla(formula,data=data,family="gaussian")
plot(y,type='l')

```

